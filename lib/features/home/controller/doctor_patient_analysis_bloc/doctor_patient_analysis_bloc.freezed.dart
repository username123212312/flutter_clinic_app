// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'doctor_patient_analysis_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$DoctorPatientAnalysisEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() analysisFetched,
    required TResult Function() clinicsFetched,
    required TResult Function(AnalysisStatus analysisStatus) statusChanged,
    required TResult Function(ClinicModel clinic) clinicChanged,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? analysisFetched,
    TResult? Function()? clinicsFetched,
    TResult? Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult? Function(ClinicModel clinic)? clinicChanged,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? analysisFetched,
    TResult Function()? clinicsFetched,
    TResult Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult Function(ClinicModel clinic)? clinicChanged,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AnalysisFetched value) analysisFetched,
    required TResult Function(ClinicsFetched value) clinicsFetched,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(ClinicChanged value) clinicChanged,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AnalysisFetched value)? analysisFetched,
    TResult? Function(ClinicsFetched value)? clinicsFetched,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(ClinicChanged value)? clinicChanged,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AnalysisFetched value)? analysisFetched,
    TResult Function(ClinicsFetched value)? clinicsFetched,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(ClinicChanged value)? clinicChanged,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoctorPatientAnalysisEventCopyWith<$Res> {
  factory $DoctorPatientAnalysisEventCopyWith(
    DoctorPatientAnalysisEvent value,
    $Res Function(DoctorPatientAnalysisEvent) then,
  ) =
      _$DoctorPatientAnalysisEventCopyWithImpl<
        $Res,
        DoctorPatientAnalysisEvent
      >;
}

/// @nodoc
class _$DoctorPatientAnalysisEventCopyWithImpl<
  $Res,
  $Val extends DoctorPatientAnalysisEvent
>
    implements $DoctorPatientAnalysisEventCopyWith<$Res> {
  _$DoctorPatientAnalysisEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AnalysisFetchedImplCopyWith<$Res> {
  factory _$$AnalysisFetchedImplCopyWith(
    _$AnalysisFetchedImpl value,
    $Res Function(_$AnalysisFetchedImpl) then,
  ) = __$$AnalysisFetchedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AnalysisFetchedImplCopyWithImpl<$Res>
    extends
        _$DoctorPatientAnalysisEventCopyWithImpl<$Res, _$AnalysisFetchedImpl>
    implements _$$AnalysisFetchedImplCopyWith<$Res> {
  __$$AnalysisFetchedImplCopyWithImpl(
    _$AnalysisFetchedImpl _value,
    $Res Function(_$AnalysisFetchedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AnalysisFetchedImpl implements AnalysisFetched {
  const _$AnalysisFetchedImpl();

  @override
  String toString() {
    return 'DoctorPatientAnalysisEvent.analysisFetched()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AnalysisFetchedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() analysisFetched,
    required TResult Function() clinicsFetched,
    required TResult Function(AnalysisStatus analysisStatus) statusChanged,
    required TResult Function(ClinicModel clinic) clinicChanged,
  }) {
    return analysisFetched();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? analysisFetched,
    TResult? Function()? clinicsFetched,
    TResult? Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult? Function(ClinicModel clinic)? clinicChanged,
  }) {
    return analysisFetched?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? analysisFetched,
    TResult Function()? clinicsFetched,
    TResult Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult Function(ClinicModel clinic)? clinicChanged,
    required TResult orElse(),
  }) {
    if (analysisFetched != null) {
      return analysisFetched();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AnalysisFetched value) analysisFetched,
    required TResult Function(ClinicsFetched value) clinicsFetched,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(ClinicChanged value) clinicChanged,
  }) {
    return analysisFetched(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AnalysisFetched value)? analysisFetched,
    TResult? Function(ClinicsFetched value)? clinicsFetched,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(ClinicChanged value)? clinicChanged,
  }) {
    return analysisFetched?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AnalysisFetched value)? analysisFetched,
    TResult Function(ClinicsFetched value)? clinicsFetched,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(ClinicChanged value)? clinicChanged,
    required TResult orElse(),
  }) {
    if (analysisFetched != null) {
      return analysisFetched(this);
    }
    return orElse();
  }
}

abstract class AnalysisFetched implements DoctorPatientAnalysisEvent {
  const factory AnalysisFetched() = _$AnalysisFetchedImpl;
}

/// @nodoc
abstract class _$$ClinicsFetchedImplCopyWith<$Res> {
  factory _$$ClinicsFetchedImplCopyWith(
    _$ClinicsFetchedImpl value,
    $Res Function(_$ClinicsFetchedImpl) then,
  ) = __$$ClinicsFetchedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ClinicsFetchedImplCopyWithImpl<$Res>
    extends _$DoctorPatientAnalysisEventCopyWithImpl<$Res, _$ClinicsFetchedImpl>
    implements _$$ClinicsFetchedImplCopyWith<$Res> {
  __$$ClinicsFetchedImplCopyWithImpl(
    _$ClinicsFetchedImpl _value,
    $Res Function(_$ClinicsFetchedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ClinicsFetchedImpl implements ClinicsFetched {
  const _$ClinicsFetchedImpl();

  @override
  String toString() {
    return 'DoctorPatientAnalysisEvent.clinicsFetched()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ClinicsFetchedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() analysisFetched,
    required TResult Function() clinicsFetched,
    required TResult Function(AnalysisStatus analysisStatus) statusChanged,
    required TResult Function(ClinicModel clinic) clinicChanged,
  }) {
    return clinicsFetched();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? analysisFetched,
    TResult? Function()? clinicsFetched,
    TResult? Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult? Function(ClinicModel clinic)? clinicChanged,
  }) {
    return clinicsFetched?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? analysisFetched,
    TResult Function()? clinicsFetched,
    TResult Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult Function(ClinicModel clinic)? clinicChanged,
    required TResult orElse(),
  }) {
    if (clinicsFetched != null) {
      return clinicsFetched();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AnalysisFetched value) analysisFetched,
    required TResult Function(ClinicsFetched value) clinicsFetched,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(ClinicChanged value) clinicChanged,
  }) {
    return clinicsFetched(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AnalysisFetched value)? analysisFetched,
    TResult? Function(ClinicsFetched value)? clinicsFetched,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(ClinicChanged value)? clinicChanged,
  }) {
    return clinicsFetched?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AnalysisFetched value)? analysisFetched,
    TResult Function(ClinicsFetched value)? clinicsFetched,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(ClinicChanged value)? clinicChanged,
    required TResult orElse(),
  }) {
    if (clinicsFetched != null) {
      return clinicsFetched(this);
    }
    return orElse();
  }
}

abstract class ClinicsFetched implements DoctorPatientAnalysisEvent {
  const factory ClinicsFetched() = _$ClinicsFetchedImpl;
}

/// @nodoc
abstract class _$$StatusChangedImplCopyWith<$Res> {
  factory _$$StatusChangedImplCopyWith(
    _$StatusChangedImpl value,
    $Res Function(_$StatusChangedImpl) then,
  ) = __$$StatusChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AnalysisStatus analysisStatus});
}

/// @nodoc
class __$$StatusChangedImplCopyWithImpl<$Res>
    extends _$DoctorPatientAnalysisEventCopyWithImpl<$Res, _$StatusChangedImpl>
    implements _$$StatusChangedImplCopyWith<$Res> {
  __$$StatusChangedImplCopyWithImpl(
    _$StatusChangedImpl _value,
    $Res Function(_$StatusChangedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? analysisStatus = null}) {
    return _then(
      _$StatusChangedImpl(
        analysisStatus:
            null == analysisStatus
                ? _value.analysisStatus
                : analysisStatus // ignore: cast_nullable_to_non_nullable
                    as AnalysisStatus,
      ),
    );
  }
}

/// @nodoc

class _$StatusChangedImpl implements StatusChanged {
  const _$StatusChangedImpl({required this.analysisStatus});

  @override
  final AnalysisStatus analysisStatus;

  @override
  String toString() {
    return 'DoctorPatientAnalysisEvent.statusChanged(analysisStatus: $analysisStatus)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StatusChangedImpl &&
            (identical(other.analysisStatus, analysisStatus) ||
                other.analysisStatus == analysisStatus));
  }

  @override
  int get hashCode => Object.hash(runtimeType, analysisStatus);

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StatusChangedImplCopyWith<_$StatusChangedImpl> get copyWith =>
      __$$StatusChangedImplCopyWithImpl<_$StatusChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() analysisFetched,
    required TResult Function() clinicsFetched,
    required TResult Function(AnalysisStatus analysisStatus) statusChanged,
    required TResult Function(ClinicModel clinic) clinicChanged,
  }) {
    return statusChanged(analysisStatus);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? analysisFetched,
    TResult? Function()? clinicsFetched,
    TResult? Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult? Function(ClinicModel clinic)? clinicChanged,
  }) {
    return statusChanged?.call(analysisStatus);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? analysisFetched,
    TResult Function()? clinicsFetched,
    TResult Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult Function(ClinicModel clinic)? clinicChanged,
    required TResult orElse(),
  }) {
    if (statusChanged != null) {
      return statusChanged(analysisStatus);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AnalysisFetched value) analysisFetched,
    required TResult Function(ClinicsFetched value) clinicsFetched,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(ClinicChanged value) clinicChanged,
  }) {
    return statusChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AnalysisFetched value)? analysisFetched,
    TResult? Function(ClinicsFetched value)? clinicsFetched,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(ClinicChanged value)? clinicChanged,
  }) {
    return statusChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AnalysisFetched value)? analysisFetched,
    TResult Function(ClinicsFetched value)? clinicsFetched,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(ClinicChanged value)? clinicChanged,
    required TResult orElse(),
  }) {
    if (statusChanged != null) {
      return statusChanged(this);
    }
    return orElse();
  }
}

abstract class StatusChanged implements DoctorPatientAnalysisEvent {
  const factory StatusChanged({required final AnalysisStatus analysisStatus}) =
      _$StatusChangedImpl;

  AnalysisStatus get analysisStatus;

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StatusChangedImplCopyWith<_$StatusChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClinicChangedImplCopyWith<$Res> {
  factory _$$ClinicChangedImplCopyWith(
    _$ClinicChangedImpl value,
    $Res Function(_$ClinicChangedImpl) then,
  ) = __$$ClinicChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ClinicModel clinic});

  $ClinicModelCopyWith<$Res> get clinic;
}

/// @nodoc
class __$$ClinicChangedImplCopyWithImpl<$Res>
    extends _$DoctorPatientAnalysisEventCopyWithImpl<$Res, _$ClinicChangedImpl>
    implements _$$ClinicChangedImplCopyWith<$Res> {
  __$$ClinicChangedImplCopyWithImpl(
    _$ClinicChangedImpl _value,
    $Res Function(_$ClinicChangedImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? clinic = null}) {
    return _then(
      _$ClinicChangedImpl(
        clinic:
            null == clinic
                ? _value.clinic
                : clinic // ignore: cast_nullable_to_non_nullable
                    as ClinicModel,
      ),
    );
  }

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClinicModelCopyWith<$Res> get clinic {
    return $ClinicModelCopyWith<$Res>(_value.clinic, (value) {
      return _then(_value.copyWith(clinic: value));
    });
  }
}

/// @nodoc

class _$ClinicChangedImpl implements ClinicChanged {
  const _$ClinicChangedImpl({required this.clinic});

  @override
  final ClinicModel clinic;

  @override
  String toString() {
    return 'DoctorPatientAnalysisEvent.clinicChanged(clinic: $clinic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClinicChangedImpl &&
            (identical(other.clinic, clinic) || other.clinic == clinic));
  }

  @override
  int get hashCode => Object.hash(runtimeType, clinic);

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ClinicChangedImplCopyWith<_$ClinicChangedImpl> get copyWith =>
      __$$ClinicChangedImplCopyWithImpl<_$ClinicChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() analysisFetched,
    required TResult Function() clinicsFetched,
    required TResult Function(AnalysisStatus analysisStatus) statusChanged,
    required TResult Function(ClinicModel clinic) clinicChanged,
  }) {
    return clinicChanged(clinic);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? analysisFetched,
    TResult? Function()? clinicsFetched,
    TResult? Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult? Function(ClinicModel clinic)? clinicChanged,
  }) {
    return clinicChanged?.call(clinic);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? analysisFetched,
    TResult Function()? clinicsFetched,
    TResult Function(AnalysisStatus analysisStatus)? statusChanged,
    TResult Function(ClinicModel clinic)? clinicChanged,
    required TResult orElse(),
  }) {
    if (clinicChanged != null) {
      return clinicChanged(clinic);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AnalysisFetched value) analysisFetched,
    required TResult Function(ClinicsFetched value) clinicsFetched,
    required TResult Function(StatusChanged value) statusChanged,
    required TResult Function(ClinicChanged value) clinicChanged,
  }) {
    return clinicChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AnalysisFetched value)? analysisFetched,
    TResult? Function(ClinicsFetched value)? clinicsFetched,
    TResult? Function(StatusChanged value)? statusChanged,
    TResult? Function(ClinicChanged value)? clinicChanged,
  }) {
    return clinicChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AnalysisFetched value)? analysisFetched,
    TResult Function(ClinicsFetched value)? clinicsFetched,
    TResult Function(StatusChanged value)? statusChanged,
    TResult Function(ClinicChanged value)? clinicChanged,
    required TResult orElse(),
  }) {
    if (clinicChanged != null) {
      return clinicChanged(this);
    }
    return orElse();
  }
}

abstract class ClinicChanged implements DoctorPatientAnalysisEvent {
  const factory ClinicChanged({required final ClinicModel clinic}) =
      _$ClinicChangedImpl;

  ClinicModel get clinic;

  /// Create a copy of DoctorPatientAnalysisEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ClinicChangedImplCopyWith<_$ClinicChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DoctorPatientAnalysisState {
  DataStatus get status => throw _privateConstructorUsedError;
  DataStatus get clinicsStatus => throw _privateConstructorUsedError;
  String get message => throw _privateConstructorUsedError;
  UserModel get patient => throw _privateConstructorUsedError;
  List<AnalysisModel> get analysisList => throw _privateConstructorUsedError;
  AnalysisStatus get analysisStatus => throw _privateConstructorUsedError;
  List<ClinicModel> get clinics => throw _privateConstructorUsedError;
  ClinicModel get selectedClinic => throw _privateConstructorUsedError;

  /// Create a copy of DoctorPatientAnalysisState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DoctorPatientAnalysisStateCopyWith<DoctorPatientAnalysisState>
  get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoctorPatientAnalysisStateCopyWith<$Res> {
  factory $DoctorPatientAnalysisStateCopyWith(
    DoctorPatientAnalysisState value,
    $Res Function(DoctorPatientAnalysisState) then,
  ) =
      _$DoctorPatientAnalysisStateCopyWithImpl<
        $Res,
        DoctorPatientAnalysisState
      >;
  @useResult
  $Res call({
    DataStatus status,
    DataStatus clinicsStatus,
    String message,
    UserModel patient,
    List<AnalysisModel> analysisList,
    AnalysisStatus analysisStatus,
    List<ClinicModel> clinics,
    ClinicModel selectedClinic,
  });

  $UserModelCopyWith<$Res> get patient;
  $ClinicModelCopyWith<$Res> get selectedClinic;
}

/// @nodoc
class _$DoctorPatientAnalysisStateCopyWithImpl<
  $Res,
  $Val extends DoctorPatientAnalysisState
>
    implements $DoctorPatientAnalysisStateCopyWith<$Res> {
  _$DoctorPatientAnalysisStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DoctorPatientAnalysisState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? clinicsStatus = null,
    Object? message = null,
    Object? patient = null,
    Object? analysisList = null,
    Object? analysisStatus = null,
    Object? clinics = null,
    Object? selectedClinic = null,
  }) {
    return _then(
      _value.copyWith(
            status:
                null == status
                    ? _value.status
                    : status // ignore: cast_nullable_to_non_nullable
                        as DataStatus,
            clinicsStatus:
                null == clinicsStatus
                    ? _value.clinicsStatus
                    : clinicsStatus // ignore: cast_nullable_to_non_nullable
                        as DataStatus,
            message:
                null == message
                    ? _value.message
                    : message // ignore: cast_nullable_to_non_nullable
                        as String,
            patient:
                null == patient
                    ? _value.patient
                    : patient // ignore: cast_nullable_to_non_nullable
                        as UserModel,
            analysisList:
                null == analysisList
                    ? _value.analysisList
                    : analysisList // ignore: cast_nullable_to_non_nullable
                        as List<AnalysisModel>,
            analysisStatus:
                null == analysisStatus
                    ? _value.analysisStatus
                    : analysisStatus // ignore: cast_nullable_to_non_nullable
                        as AnalysisStatus,
            clinics:
                null == clinics
                    ? _value.clinics
                    : clinics // ignore: cast_nullable_to_non_nullable
                        as List<ClinicModel>,
            selectedClinic:
                null == selectedClinic
                    ? _value.selectedClinic
                    : selectedClinic // ignore: cast_nullable_to_non_nullable
                        as ClinicModel,
          )
          as $Val,
    );
  }

  /// Create a copy of DoctorPatientAnalysisState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $UserModelCopyWith<$Res> get patient {
    return $UserModelCopyWith<$Res>(_value.patient, (value) {
      return _then(_value.copyWith(patient: value) as $Val);
    });
  }

  /// Create a copy of DoctorPatientAnalysisState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClinicModelCopyWith<$Res> get selectedClinic {
    return $ClinicModelCopyWith<$Res>(_value.selectedClinic, (value) {
      return _then(_value.copyWith(selectedClinic: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$DoctorPatientAnalysisStateImplCopyWith<$Res>
    implements $DoctorPatientAnalysisStateCopyWith<$Res> {
  factory _$$DoctorPatientAnalysisStateImplCopyWith(
    _$DoctorPatientAnalysisStateImpl value,
    $Res Function(_$DoctorPatientAnalysisStateImpl) then,
  ) = __$$DoctorPatientAnalysisStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    DataStatus status,
    DataStatus clinicsStatus,
    String message,
    UserModel patient,
    List<AnalysisModel> analysisList,
    AnalysisStatus analysisStatus,
    List<ClinicModel> clinics,
    ClinicModel selectedClinic,
  });

  @override
  $UserModelCopyWith<$Res> get patient;
  @override
  $ClinicModelCopyWith<$Res> get selectedClinic;
}

/// @nodoc
class __$$DoctorPatientAnalysisStateImplCopyWithImpl<$Res>
    extends
        _$DoctorPatientAnalysisStateCopyWithImpl<
          $Res,
          _$DoctorPatientAnalysisStateImpl
        >
    implements _$$DoctorPatientAnalysisStateImplCopyWith<$Res> {
  __$$DoctorPatientAnalysisStateImplCopyWithImpl(
    _$DoctorPatientAnalysisStateImpl _value,
    $Res Function(_$DoctorPatientAnalysisStateImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DoctorPatientAnalysisState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? status = null,
    Object? clinicsStatus = null,
    Object? message = null,
    Object? patient = null,
    Object? analysisList = null,
    Object? analysisStatus = null,
    Object? clinics = null,
    Object? selectedClinic = null,
  }) {
    return _then(
      _$DoctorPatientAnalysisStateImpl(
        status:
            null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                    as DataStatus,
        clinicsStatus:
            null == clinicsStatus
                ? _value.clinicsStatus
                : clinicsStatus // ignore: cast_nullable_to_non_nullable
                    as DataStatus,
        message:
            null == message
                ? _value.message
                : message // ignore: cast_nullable_to_non_nullable
                    as String,
        patient:
            null == patient
                ? _value.patient
                : patient // ignore: cast_nullable_to_non_nullable
                    as UserModel,
        analysisList:
            null == analysisList
                ? _value._analysisList
                : analysisList // ignore: cast_nullable_to_non_nullable
                    as List<AnalysisModel>,
        analysisStatus:
            null == analysisStatus
                ? _value.analysisStatus
                : analysisStatus // ignore: cast_nullable_to_non_nullable
                    as AnalysisStatus,
        clinics:
            null == clinics
                ? _value._clinics
                : clinics // ignore: cast_nullable_to_non_nullable
                    as List<ClinicModel>,
        selectedClinic:
            null == selectedClinic
                ? _value.selectedClinic
                : selectedClinic // ignore: cast_nullable_to_non_nullable
                    as ClinicModel,
      ),
    );
  }
}

/// @nodoc

class _$DoctorPatientAnalysisStateImpl implements _DoctorPatientAnalysisState {
  const _$DoctorPatientAnalysisStateImpl({
    required this.status,
    required this.clinicsStatus,
    required this.message,
    required this.patient,
    required final List<AnalysisModel> analysisList,
    required this.analysisStatus,
    required final List<ClinicModel> clinics,
    required this.selectedClinic,
  }) : _analysisList = analysisList,
       _clinics = clinics;

  @override
  final DataStatus status;
  @override
  final DataStatus clinicsStatus;
  @override
  final String message;
  @override
  final UserModel patient;
  final List<AnalysisModel> _analysisList;
  @override
  List<AnalysisModel> get analysisList {
    if (_analysisList is EqualUnmodifiableListView) return _analysisList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_analysisList);
  }

  @override
  final AnalysisStatus analysisStatus;
  final List<ClinicModel> _clinics;
  @override
  List<ClinicModel> get clinics {
    if (_clinics is EqualUnmodifiableListView) return _clinics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_clinics);
  }

  @override
  final ClinicModel selectedClinic;

  @override
  String toString() {
    return 'DoctorPatientAnalysisState(status: $status, clinicsStatus: $clinicsStatus, message: $message, patient: $patient, analysisList: $analysisList, analysisStatus: $analysisStatus, clinics: $clinics, selectedClinic: $selectedClinic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DoctorPatientAnalysisStateImpl &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.clinicsStatus, clinicsStatus) ||
                other.clinicsStatus == clinicsStatus) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.patient, patient) || other.patient == patient) &&
            const DeepCollectionEquality().equals(
              other._analysisList,
              _analysisList,
            ) &&
            (identical(other.analysisStatus, analysisStatus) ||
                other.analysisStatus == analysisStatus) &&
            const DeepCollectionEquality().equals(other._clinics, _clinics) &&
            (identical(other.selectedClinic, selectedClinic) ||
                other.selectedClinic == selectedClinic));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    status,
    clinicsStatus,
    message,
    patient,
    const DeepCollectionEquality().hash(_analysisList),
    analysisStatus,
    const DeepCollectionEquality().hash(_clinics),
    selectedClinic,
  );

  /// Create a copy of DoctorPatientAnalysisState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DoctorPatientAnalysisStateImplCopyWith<_$DoctorPatientAnalysisStateImpl>
  get copyWith => __$$DoctorPatientAnalysisStateImplCopyWithImpl<
    _$DoctorPatientAnalysisStateImpl
  >(this, _$identity);
}

abstract class _DoctorPatientAnalysisState
    implements DoctorPatientAnalysisState {
  const factory _DoctorPatientAnalysisState({
    required final DataStatus status,
    required final DataStatus clinicsStatus,
    required final String message,
    required final UserModel patient,
    required final List<AnalysisModel> analysisList,
    required final AnalysisStatus analysisStatus,
    required final List<ClinicModel> clinics,
    required final ClinicModel selectedClinic,
  }) = _$DoctorPatientAnalysisStateImpl;

  @override
  DataStatus get status;
  @override
  DataStatus get clinicsStatus;
  @override
  String get message;
  @override
  UserModel get patient;
  @override
  List<AnalysisModel> get analysisList;
  @override
  AnalysisStatus get analysisStatus;
  @override
  List<ClinicModel> get clinics;
  @override
  ClinicModel get selectedClinic;

  /// Create a copy of DoctorPatientAnalysisState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DoctorPatientAnalysisStateImplCopyWith<_$DoctorPatientAnalysisStateImpl>
  get copyWith => throw _privateConstructorUsedError;
}
